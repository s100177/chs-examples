# 渠道系统MIMO MPC + PID 级联控制示例

本示例在先前版本的基础上进行了显著升级，实现了一个**多输入多输出（MIMO）**的MPC控制器，用于对整个渠道系统进行全局优化和协调控制。

## 系统描述

系统拓扑结构保持不变，核心目的是在存在多种扰动的情况下，精确、稳定地控制`canal_1`的水位。

`reservoir` -> `diversion_1` -> `gate_1` -> `canal_1` -> `diversion_2` -> `gate_2` -> `tail_user`

## 控制架构哲学：中心化 vs. 块去中心化

在设计类似本例的控制系统时，一个根本性的问题是选择控制的“粒度”。这引出了中心化与去中心化两种设计哲学的讨论。

-   **纯粹中心化 (Purely Centralized):** 一个“上帝”控制器（例如一个覆盖全系统的MPC）收集所有信息，进行全局优化，并直接控制每一个执行器（如所有闸门）。理论上能达到全局最优，但系统庞大、复杂，且存在单点故障风险。
-   **纯粹去中心化 (Purely Decentralized):** 每个执行器（如每个闸门）都由一个独立的本地控制器（`LocalControlAgent`）管理，只依赖局部信息。这种方式鲁棒性强、易于扩展，但可能会因为缺乏协调而导致局部控制器“打架”，尤其是在组件间**强耦合**的场景下。

本示例中的MIMO MPC控制器，实际上采用了一种更高级、更实用的**“块去中心化” (Block-Decentralized)** 策略。

-   **核心思想:** 它没有走向任何一个极端。而是将整个系统划分为若干个“控制块”，每个块内包含一组紧密耦合的组件（如此处的`gate_1`和`gate_2`）。
-   **实现方式:** 一个MIMO MPC作为块的“大脑”，在块内部进行统一协调和优化，因为它能够理解和处理块内组件（两个闸门）之间的相互影响。
-   **优势:** 这种设计兼具两种哲学的优点。从整个运河系统来看，它依然是**去中心化的**（可以有多个这样的控制块，分别管理不同河段），保持了高鲁棒性和扩展性。而在每个块的**内部**，它又是**中心化的**，从而能够对强耦合对象进行最优协调，避免了控制冲突。

因此，本示例展示的是一种在大型复杂系统中平衡最优性与可行性的工程智慧，是分布式控制思想在现实场景中的成熟应用。

## 控制架构对比分析

在设计复杂系统的分层控制策略时，核心决策之一是顶层控制器（MPC）应该向下层控制器（PID）下发何种指令。这直接决定了系统的性能和稳定性。

### 方案一：MPC下发【流量目标】（级联控制，**本示例默认实现**）

-   **架构**: 外环MPC负责水位稳定，内环PID负责流量追踪。
-   **工作原理**:
    1.  **外环 (MPC)**: 作为战略层，以“维持渠段水位稳定”为最终目标，计算出每个闸门应通过的**最优流量**。
    2.  **内环 (PID)**: 作为执行层，每个闸门有一个独立的**流量PID控制器**，接收MPC下发的流量目标，并快速调整闸门开度以精确执行。
-   **优点**:
    -   **稳定性高**: 任务清晰解耦，内环PID目标独立（只管自己的流量），不会互相“打架”。
    -   **响应速度快**: 内环流量回路能迅速抑制局部流量扰动，防止其对水位造成大的影响。
    -   **鲁棒性强**: 内环PID能很好地处理执行器的非线性等局部问题，为MPC屏蔽了底层复杂性。
-   **缺点**:
    -   **感知要求高**: 需要准确测量或估算每个闸门的实时流量。
-   **结论**: **工业级标准方案**，稳定、高效、鲁棒。

### 方案二：MPC下发【水位目标】

-   **架构**: MPC和PID都以水位为目标。
-   **工作原理**: MPC计算出渠道中最优的水位目标，并下发给所有相关的PID控制器，由它们调整闸门来追踪该水位。
-   **优点**:
    -   **感知要求低**: 只需要水位传感器。
    -   **逻辑直观**: 顶层和底层的目标统一。
-   **缺点**:
    -   **控制冲突**: 在本例这样的串联系统中，`gate_1`和`gate_2`的PID会为了同一个水位目标而相互对抗（一个想多放水，一个想少放水），极易导致系统振荡。
-   **结论**: **仅适用于简单场景**，在强耦合系统中存在致命的设计缺陷。

*我们提供了一个基于`ScenarioAgent`模拟此方案的配置文件 `agents_level_control.yml`，供您运行和观察其不稳定的振荡行为，以作对比验证。*

---

## 本示例实现细节 (方案一)

### 基于情景的扰动管理
本示例采用一个中央`ScenarioAgent`来统一调度所有扰动事件。它从`agents.yml`文件中的`scenario_script`部分读取一个预设的事件脚本，在特定时间注入流量扰动。

### 如何运行
本示例是数据驱动的。默认运行的是**方案一（MPC下发流量）**。
```bash
python run_scenario.py examples/canal_model/canal_mpc_pid_control
```

要运行**方案二（MPC下发水位）**的模拟，以观察其控制冲突，请使用`--agents`参数指定备用配置文件：
```bash
python run_scenario.py examples/canal_model/canal_mpc_pid_control --agents agents_level_control.yml
```

### 预期结果
脚本将执行模拟，并将所有组件和智能体的详细历史记录保存到 `output.yml` 文件中。您可以对比两个方案的输出，以评估不同控制架构的性能。
