# 案例五：联合控制

## 1. 案例目标

本案例旨在演示一个更复杂的控制场景：一个水箱的水位同时受到一个**可控的进水泵**、一个**可控的出水阀**以及一个**不可控的外部扰动**（如固定的水量流失或侧向入流）的共同影响。

目标是通过一个**协调器智能体（Coordinator Agent）**，联合调度水泵和水阀，以对抗扰动，将水位维持在目标设定点。

## 2. 架构设计

本案例采用基于智能体的事件驱动架构：

- **物理对象 (`Reservoir`)**: 模拟水箱的核心物理过程。
- **感知智能体 (`DigitalTwinAgent`)**: 封装 `Reservoir` 对象，负责感知其状态（如水位），并将其发布到消息总线。
- **协调控制智能体 (`JointControlCoordinatorAgent`)**: 这是本案例的核心。
    - 它订阅水位状态信息。
    - 内置一个PID控制器，根据水位误差计算出一个总的“净流量需求”。
    - 根据一个预设的策略（例如，需要补水时开泵，需要排水时开阀），将这个净流量需求分解为对水泵和水阀的具体流量指令。
    - 将指令发布到各自的命令主题上。
- **主程序 (`main.py`)**:
    - 负责初始化所有组件和消息总线。
    - 在仿真循环中，模拟不可控的外部扰动。
    - 从消息总线订阅最终的控制指令，并将其施加于 `Reservoir` 物理对象。

这种解耦的架构使得更换控制策略（修改`JointControlCoordinatorAgent`的内部分配逻辑）或物理模型都变得非常容易，而无需改动其他部分。

## 3. 文件结构

- `main.py`: 仿真的主入口，负责组装和运行整个系统。
- `joint_control_agent.py`: 定义了核心的 `JointControlCoordinatorAgent`。
- `config.json`: 配置文件，定义了水箱、PID控制器、执行器限幅、扰动模式和所有消息主题。
- `README.md`: 本说明文档。

## 4. 如何运行

在 `05_joint_control` 目录下，直接运行主程序：

```bash
python main.py
```

仿真结束后，结果将保存在 `examples/watertank/logs/05_joint_control/joint_control_log.csv` 文件中。该文件记录了水位、设定点、水泵和水阀的控制动作以及外部扰动。
